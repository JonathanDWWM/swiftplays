generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  password    String?  // Optionnel pour les comptes Discord
  pseudo      String   @unique
  firstName   String?
  lastName    String?
  avatar      String?  // URL vers l'image de profil
  isVerified  Boolean  @default(false)
  role        Role     @default(USER)

  // Discord OAuth
  discordId       String? @unique // ID Discord de l'utilisateur
  discordUsername String? // Nom d'utilisateur Discord
  discordAvatar   String? // URL de l'avatar Discord
  
  // Type de compte
  accountType     AccountType @default(EMAIL)

  // Relations √©quipes
  ownedTeams      Team[]       @relation("TeamOwner")
  teamMemberships TeamMember[]
  
  // Relations messages
  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")
  
  // Relations notifications (√† supprimer apr√®s migration)
  notifications   Notification[]
  
  // Pr√©f√©rences notifications
  notificationSettings NotificationSettings?

  // Relations ladder
  ladderPlayers   LadderPlayer[]
  
  // Relations admin
  adminActionsPerformed AdminAction[] @relation("AdminActionPerformer")
  adminActionsReceived  AdminAction[] @relation("AdminActionTarget")
  sanctionsGiven       UserSanction[] @relation("SanctionGiver")
  sanctionsReceived    UserSanction[] @relation("UserSanctions")

  // Relations chat
  chatMessages        ChatMessage[] @relation("ChatMessageSender")
  conversationMembers ConversationMember[]
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("users")
}

enum Role {
  USER
  MODERATOR
  ADMIN
}

enum AccountType {
  EMAIL    // Compte cr√©√© avec email/password
  DISCORD  // Compte cr√©√© via Discord OAuth
  HYBRID   // Compte email li√© √† Discord
}

// Mod√®les pour l'administration
model AdminAction {
  id          String        @id @default(cuid())
  type        AdminActionType
  description String
  targetUserId String?
  targetUser   User?        @relation("AdminActionTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  adminUserId  String
  adminUser    User         @relation("AdminActionPerformer", fields: [adminUserId], references: [id])
  metadata     Json?        // Donn√©es additionnelles (raison, dur√©e, etc.)
  createdAt    DateTime     @default(now())

  @@map("admin_actions")
  @@index([adminUserId])
  @@index([targetUserId])
  @@index([createdAt])
}

model UserSanction {
  id          String         @id @default(cuid())
  type        SanctionType
  reason      String
  duration    Int?           // Dur√©e en heures (null = permanent)
  isActive    Boolean        @default(true)
  userId      String
  user        User          @relation("UserSanctions", fields: [userId], references: [id], onDelete: Cascade)
  adminUserId String
  adminUser   User          @relation("SanctionGiver", fields: [adminUserId], references: [id])
  expiresAt   DateTime?     // Date d'expiration (calcul√©e)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@map("user_sanctions")
  @@index([userId, isActive])
  @@index([expiresAt])
}

enum AdminActionType {
  USER_WARN
  USER_BAN
  USER_UNBAN
  USER_KICK
  TEAM_DISSOLVE
  TEAM_TRANSFER_CAPTAIN
  MATCH_RESOLVE_DISPUTE
  CONTENT_MODERATE
}

enum SanctionType {
  WARNING
  TEMPORARY_BAN
  PERMANENT_BAN
  CHAT_MUTE
}

model Team {
  id          String   @id @default(cuid())
  name        String   @unique // Nom unique de l'√©quipe
  shortName   String   @unique // Nom court (3 caract√®res)
  description String?  // Description optionnelle
  avatar      String?  // URL de l'avatar de l'√©quipe
  game        Game     // Jeu de l'√©quipe
  gameMode    String   // Mode de jeu selon le jeu
  maxMembers  Int      // Limite de membres selon le jeu/mode
  
  // Relations
  ownerId     String
  owner       User           @relation("TeamOwner", fields: [ownerId], references: [id])
  members     TeamMember[]
  
  // Relations matches
  matchesAsTeam1  Match[]    @relation("MatchTeam1")
  matchesAsTeam2  Match[]    @relation("MatchTeam2")
  
  // Relations chat
  teamConversation Conversation? @relation("TeamConversation")
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("teams")
}

enum Game {
  FC_26               // FIFA 26 - 1v1, 2v2, 5v5
  CALL_OF_DUTY_BO7    // Call of Duty Black Ops 7 - 1v1, 2v2, 4v4
}

model TeamMember {
  id       String          @id @default(cuid())
  role     TeamMemberRole  @default(MEMBER)
  
  // Relations
  teamId   String
  userId   String
  team     Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Timestamps
  joinedAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([teamId, userId]) // Un user ne peut √™tre qu'une fois dans une √©quipe
  @@map("team_members")
}

enum TeamMemberRole {
  CAPTAIN      // Capitaine (m√™me personne que owner)
  CO_CAPTAIN   // Vice-capitaine
  MEMBER       // Membre standard
}



model Notification {
  id       String           @id @default(cuid())
  type     NotificationType
  title    String           // Titre de la notification
  message  String           // Message de la notification
  data     Json?            // Donn√©es JSON additionnelles (ex: ID √©quipe, etc.)
  isRead   Boolean          @default(false)
  
  // Relations
  userId   String
  user     User @relation(fields: [userId], references: [id])
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("notifications")
  @@index([userId, isRead])
  @@index([userId, createdAt])
}

enum NotificationType {
  SYSTEM                // Notification syst√®me g√©n√©rale
}

model Message {
  id          String        @id @default(cuid())
  type        MessageType   
  category    MessageCategory @default(NOTIFICATION)
  title       String        
  content     String        
  isRead      Boolean       @default(false)
  
  // Actions int√©gr√©es (JSON)
  actions     Json?         // Boutons dynamiques : accepter/refuser/voir/etc.
  data        Json?         // Donn√©es contextuelles (teamId, invitationId, etc.)
  
  // Relations
  senderId    String?       // Optionnel pour messages syst√®me
  receiverId  String
  sender      User?         @relation("SentMessages", fields: [senderId], references: [id])
  receiver    User          @relation("ReceivedMessages", fields: [receiverId], references: [id])
  
  // M√©tadonn√©es
  priority    Priority      @default(NORMAL)
  expiresAt   DateTime?     // Pour invitations avec timeout
  
  // Timestamps
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  @@map("messages")
  @@index([receiverId, isRead])
  @@index([receiverId, createdAt])
  @@index([receiverId, category])
}

enum MessageType {
  // Syst√®me & Onboarding
  SYSTEM_WELCOME
  SYSTEM_UPDATE
  SYSTEM_MAINTENANCE
  ONBOARDING_GUIDE
  FIRST_TEAM_CREATED
  FIRST_CHALLENGE_CREATED
  ACHIEVEMENT_UNLOCKED
  
  // √âquipes
  TEAM_INVITATION
  TEAM_INVITATION_ACCEPTED
  TEAM_INVITATION_DECLINED
  TEAM_MEMBER_JOINED
  TEAM_MEMBER_LEFT
  TEAM_ROLE_CHANGED
  TEAM_DISBANDED
  
  // D√©fis & Matches
  CHALLENGE_CREATED
  CHALLENGE_RECEIVED
  CHALLENGE_ACCEPTED
  CHALLENGE_DECLINED
  CHALLENGE_EXPIRED
  MATCH_REMINDER
  MATCH_STARTED
  MATCH_RESULT_SUBMITTED
  MATCH_RESULT_CONFIRMED
  MATCH_RESULT_DISPUTED
  MATCH_DISPUTE_RESOLVED
  
  // Chat & Communication
  PRIVATE_MESSAGE
  TEAM_CHAT_MESSAGE
  MATCH_CHAT_MESSAGE
  
  // Tournois (futur)
  TOURNAMENT_INVITE
  TOURNAMENT_STARTED
  TOURNAMENT_REMINDER
  
  // Social (futur)
  FRIEND_REQUEST
  LOBBY_INVITE
}

enum MessageCategory {
  NOTIFICATION    // Notifications classiques (informatives)
  INVITATION     // N√©cessitent une action (accepter/refuser)
  SYSTEM         // Messages syst√®me et onboarding
  ACHIEVEMENT    // Accomplissements et f√©licitations
  REMINDER       // Rappels de matchs/√©v√©nements
  CHAT           // Messages de chat temps r√©el
  ALERT          // Alertes importantes/urgentes
}

enum Priority {
  LOW
  NORMAL  
  HIGH
  URGENT
}

// ===========================
// SYST√àME LADDER INDIVIDUEL
// ===========================

model LadderPlayer {
  id          String   @id @default(cuid())
  
  // Relations
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Statistiques par jeu et mode
  game        Game
  gameMode    String   // "1v1" pour les comp√©titions individuelles
  
  // Statistiques
  victories   Int      @default(0)
  defeats     Int      @default(0)
  matchesPlayed Int    @default(0)
  
  // Position dans le classement (calcul√©e dynamiquement)
  rank        Int?
  
  // Derni√®re activit√©
  lastMatchAt DateTime?
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations matches
  challengesCreated   Challenge[]  @relation("ChallengeCreator")
  challengesAccepted  Challenge[]  @relation("ChallengeAcceptor")
  matchesAsPlayer1    Match[]      @relation("MatchPlayer1")
  matchesAsPlayer2    Match[]      @relation("MatchPlayer2")
  
  @@unique([userId, game, gameMode])
  @@map("ladder_players")
  @@index([game, gameMode, victories, defeats])
}

model Challenge {
  id            String          @id @default(cuid())
  
  // Relations
  creatorId     String
  acceptorId    String?
  creator       LadderPlayer    @relation("ChallengeCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  acceptor      LadderPlayer?   @relation("ChallengeAcceptor", fields: [acceptorId], references: [id], onDelete: SetNull)
  
  // Informations du d√©fi
  game          Game
  gameMode      String          // "1v1"
  scheduledAt   DateTime        // Heure pr√©vue du match
  expiresAt     DateTime        // Heure limite d'acceptation (= scheduledAt)
  
  // Statuts
  status        ChallengeStatus @default(PENDING)
  
  // Message optionnel
  message       String?
  
  // Match associ√© (une fois accept√©)
  matchId       String?         @unique
  match         Match?          @relation(fields: [matchId], references: [id])
  
  // Timestamps
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  @@map("challenges")
  @@index([game, gameMode, status])
  @@index([scheduledAt, status])
}

enum ChallengeStatus {
  PENDING     // En attente d'acceptation
  ACCEPTED    // Accept√©, match en cours
  EXPIRED     // Expir√© (heure pass√©e)
  CANCELLED   // Annul√© par le cr√©ateur
  COMPLETED   // Match termin√©
}

model Match {
  id            String      @id @default(cuid())
  
  // Relations (flexible pour 1v1 et √©quipes)
  player1Id     String?     // Pour mode 1v1
  player2Id     String?     // Pour mode 1v1
  team1Id       String?     // Pour mode √©quipe
  team2Id       String?     // Pour mode √©quipe
  
  player1       LadderPlayer? @relation("MatchPlayer1", fields: [player1Id], references: [id])
  player2       LadderPlayer? @relation("MatchPlayer2", fields: [player2Id], references: [id])
  team1         Team?        @relation("MatchTeam1", fields: [team1Id], references: [id])
  team2         Team?        @relation("MatchTeam2", fields: [team2Id], references: [id])
  
  // Challenge d'origine
  challenge     Challenge?
  
  // Informations du match
  game          Game
  gameMode      String      // "1v1", "2v2", "4v4", "5v5"
  scheduledAt   DateTime    // Heure pr√©vue du match
  
  // R√©sultat
  status        MatchStatus @default(IN_PROGRESS)
  winnerId      String?     // ID du gagnant (LadderPlayer ou Team)
  loserId       String?     // ID du perdant (LadderPlayer ou Team)
  
  // Score (optionnel)
  score1        Int?        // Score √©quipe/joueur 1
  score2        Int?        // Score √©quipe/joueur 2
  
  // Soumissions de r√©sultats
  submissions   MatchSubmission[]
  
  // Validation du r√©sultat
  isDisputed        Boolean    @default(false)
  validationDeadline DateTime? // Deadline pour confirmer (24h)
  
  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  completedAt   DateTime?   // Quand le match a √©t√© compl√©t√©
  
  // Relation avec les conflits
  disputes      Dispute[]
  
  @@map("matches")
  @@index([game, gameMode, status])
  @@index([scheduledAt])
  @@index([status, createdAt])
  @@index([validationDeadline])
}

enum MatchStatus {
  IN_PROGRESS   // Match en cours
  AWAITING_RESULTS  // En attente de soumission de r√©sultats
  AWAITING_CONFIRMATION  // En attente de confirmation (24h)
  COMPLETED     // Match termin√© et valid√©
  DISPUTED      // R√©sultat contest√©
  CANCELLED     // Match annul√©
  AUTO_VALIDATED  // Valid√© automatiquement (timeout)
}

model MatchSubmission {
  id          String        @id @default(cuid())
  
  // Relations
  matchId     String
  match       Match         @relation(fields: [matchId], references: [id], onDelete: Cascade)
  submittedBy String        // User ID qui a soumis
  
  // R√©sultat soumis
  winnerId    String        // ID du gagnant d√©clar√© (Team ou LadderPlayer)
  score1      Int?          // Score √©quipe/joueur 1
  score2      Int?          // Score √©quipe/joueur 2
  
  // M√©tadonn√©es
  submitterRole String?     // "CAPTAIN", "CO_CAPTAIN" pour tracking
  comments    String?       // Commentaires optionnels
  
  // Status
  isValidated Boolean       @default(false)
  
  // Preuves (si litige)
  evidenceUrls Json?        // URLs des fichiers de preuve
  
  // Timestamps
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  @@unique([matchId, submittedBy]) // Un utilisateur ne peut soumettre qu'une fois par match
  @@map("match_submissions")
  @@index([matchId])
  @@index([submittedBy])
}

model Dispute {
  id          String        @id @default(cuid())
  
  // Relations
  matchId     String
  match       Match         @relation(fields: [matchId], references: [id], onDelete: Cascade)
  disputedBy  String        // ID du joueur qui conteste (User ID)
  
  // D√©tails du conflit
  reason      String        // Raison du conflit
  description String?       // Description d√©taill√©e
  proofUrls   Json?         // URLs des preuves du joueur qui conteste
  
  // Statut
  status      DisputeStatus @default(PENDING)
  
  // R√©solution
  resolvedBy  String?       // ID de l'admin/mod√©rateur qui r√©sout
  resolution  String?       // Explication de la r√©solution
  resolvedAt  DateTime?
  
  // Timestamps
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  @@map("disputes")
  @@index([status])
  @@index([createdAt])
}

enum DisputeStatus {
  PENDING     // En attente de r√©solution
  RESOLVED    // R√©solu
  REJECTED    // Rejet√© (pas de conflit valide)
}

// ===========================
// PR√âF√âRENCES NOTIFICATIONS
// ===========================

model NotificationSettings {
  id       String @id @default(cuid())
  
  // Relation
  userId   String @unique
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Param√®tres g√©n√©raux
  enableWebNotifications    Boolean @default(true)   // Notifications web/site
  enableEmailNotifications Boolean @default(true)   // Emails
  enablePushNotifications  Boolean @default(false)  // Push mobile (futur)
  
  // √âquipes
  teamInvitations          Boolean @default(true)   // Invitations d'√©quipe
  teamUpdates             Boolean @default(true)   // Mises √† jour √©quipe
  teamChat                Boolean @default(true)   // Messages √©quipe
  
  // D√©fis et matchs
  challengeReceived       Boolean @default(true)   // D√©fis re√ßus
  challengeAccepted       Boolean @default(true)   // D√©fi accept√©
  matchReminders          Boolean @default(true)   // Rappels de match
  matchResults            Boolean @default(true)   // R√©sultats de match
  matchDisputes           Boolean @default(true)   // Litiges
  
  // Onboarding et syst√®me
  systemMessages          Boolean @default(true)   // Messages syst√®me
  achievements            Boolean @default(true)   // Accomplissements
  onboardingGuides        Boolean @default(true)   // Guides d'aide
  
  // Chat et social
  privateMessages         Boolean @default(true)   // Messages priv√©s
  socialUpdates           Boolean @default(false)  // Mises √† jour sociales
  friendRequests          Boolean @default(true)   // Demandes d'amis
  
  // Heures de tranquillit√© (Do Not Disturb)
  quietHoursEnabled       Boolean @default(false)
  quietHoursStart         String? // Format HH:MM
  quietHoursEnd           String? // Format HH:MM
  quietHoursTimezone      String @default("Europe/Paris")
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("notification_settings")
  @@index([userId])
}

// ===========================
// SYST√àME DE CHAT TEMPS R√âEL
// ===========================

model Conversation {
  id          String             @id @default(cuid())
  type        ConversationType
  title       String?            // Titre pour groupes/√©quipes
  description String?            // Description optionnelle
  
  // Relations
  teamId      String?            @unique // Pour chat √©quipe
  team        Team?              @relation("TeamConversation", fields: [teamId], references: [id], onDelete: Cascade)
  matchId     String?            // Pour chat pr√©-match (futur)
  
  // M√©tadonn√©es
  isActive    Boolean            @default(true)
  lastActivity DateTime?         // Derni√®re activit√©
  
  // Relations
  members     ConversationMember[]
  messages    ChatMessage[]
  
  // Timestamps
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  
  @@map("conversations")
  @@index([type])
  @@index([teamId])
  @@index([lastActivity])
}

model ConversationMember {
  id             String       @id @default(cuid())
  
  // Relations
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Statut
  role           ChatRole     @default(MEMBER)
  isActive       Boolean      @default(true)
  lastReadAt     DateTime?    // Derni√®re lecture pour notifications non-lues
  
  // M√©tadonn√©es
  joinedAt       DateTime     @default(now())
  mutedUntil     DateTime?    // Mute temporaire
  
  @@map("conversation_members")
  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId, isActive])
}

model ChatMessage {
  id             String       @id @default(cuid())
  content        String
  type           ChatMessageType @default(TEXT)
  
  // Relations
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User         @relation("ChatMessageSender", fields: [senderId], references: [id])
  
  // M√©tadonn√©es
  isEdited       Boolean      @default(false)
  editedAt       DateTime?
  isDeleted      Boolean      @default(false)
  deletedAt      DateTime?
  
  // R√©actions (futur)
  reactions      Json?        // Emoji reactions { "üëç": ["userId1", "userId2"], ... }
  
  // R√©ponse √† un message (futur)
  replyToId      String?
  replyTo        ChatMessage? @relation("MessageReplies", fields: [replyToId], references: [id])
  replies        ChatMessage[] @relation("MessageReplies")
  
  // Mod√©ration
  isFlagged      Boolean      @default(false)
  flaggedReason  String?
  moderatedBy    String?
  moderatedAt    DateTime?
  
  // Timestamps
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  
  @@map("chat_messages")
  @@index([conversationId, createdAt])
  @@index([senderId])
  @@index([createdAt])
}

enum ConversationType {
  DIRECT      // Message priv√© 1v1
  TEAM        // Chat √©quipe
  MATCH       // Chat pr√©/post match entre √©quipes
  GROUP       // Groupe personnalis√© (futur)
  SUPPORT     // Support/aide (futur)
}

enum ChatRole {
  MEMBER      // Membre standard
  MODERATOR   // Mod√©rateur de conversation
  ADMIN       // Admin de conversation
}

enum ChatMessageType {
  TEXT        // Message texte standard
  SYSTEM      // Message syst√®me (x a rejoint, x a quitt√©)
  FILE        // Fichier partag√© (futur)
  IMAGE       // Image partag√©e (futur)
  MATCH_UPDATE // Mise √† jour de match (score, etc)
}

