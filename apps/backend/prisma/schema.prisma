generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  password    String?  // Optionnel pour les comptes Discord
  pseudo      String   @unique
  firstName   String?
  lastName    String?
  avatar      String?  // URL vers l'image de profil
  isVerified  Boolean  @default(false)
  role        Role     @default(USER)

  // Discord OAuth
  discordId       String? @unique // ID Discord de l'utilisateur
  discordUsername String? // Nom d'utilisateur Discord
  discordAvatar   String? // URL de l'avatar Discord
  
  // Type de compte
  accountType     AccountType @default(EMAIL)

  // Relations équipes
  ownedTeams      Team[]       @relation("TeamOwner")
  teamMemberships TeamMember[]
  
  // Relations messages
  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")
  
  // Relations notifications (à supprimer après migration)
  notifications   Notification[]

  // Relations ladder
  ladderPlayers   LadderPlayer[]

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("users")
}

enum Role {
  USER
  MODERATOR
  ADMIN
}

enum AccountType {
  EMAIL    // Compte créé avec email/password
  DISCORD  // Compte créé via Discord OAuth
  HYBRID   // Compte email lié à Discord
}

model Team {
  id          String   @id @default(cuid())
  name        String   @unique // Nom unique de l'équipe
  shortName   String   @unique // Nom court (3 caractères)
  description String?  // Description optionnelle
  avatar      String?  // URL de l'avatar de l'équipe
  game        Game     // Jeu de l'équipe
  gameMode    String   // Mode de jeu selon le jeu
  maxMembers  Int      // Limite de membres selon le jeu/mode
  
  // Relations
  ownerId     String
  owner       User           @relation("TeamOwner", fields: [ownerId], references: [id])
  members     TeamMember[]
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("teams")
}

enum Game {
  FC_26               // FIFA 26 - 1v1, 2v2, 5v5
  CALL_OF_DUTY_BO7    // Call of Duty Black Ops 7 - 1v1, 2v2, 4v4
}

model TeamMember {
  id       String          @id @default(cuid())
  role     TeamMemberRole  @default(MEMBER)
  
  // Relations
  teamId   String
  userId   String
  team     Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Timestamps
  joinedAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([teamId, userId]) // Un user ne peut être qu'une fois dans une équipe
  @@map("team_members")
}

enum TeamMemberRole {
  CAPTAIN      // Capitaine (même personne que owner)
  CO_CAPTAIN   // Vice-capitaine
  MEMBER       // Membre standard
}



model Notification {
  id       String           @id @default(cuid())
  type     NotificationType
  title    String           // Titre de la notification
  message  String           // Message de la notification
  data     Json?            // Données JSON additionnelles (ex: ID équipe, etc.)
  isRead   Boolean          @default(false)
  
  // Relations
  userId   String
  user     User @relation(fields: [userId], references: [id])
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("notifications")
  @@index([userId, isRead])
  @@index([userId, createdAt])
}

enum NotificationType {
  SYSTEM                // Notification système générale
}

model Message {
  id          String        @id @default(cuid())
  type        MessageType   
  category    MessageCategory @default(NOTIFICATION)
  title       String        
  content     String        
  isRead      Boolean       @default(false)
  
  // Actions intégrées (JSON)
  actions     Json?         // Boutons dynamiques : accepter/refuser/voir/etc.
  data        Json?         // Données contextuelles (teamId, invitationId, etc.)
  
  // Relations
  senderId    String?       // Optionnel pour messages système
  receiverId  String
  sender      User?         @relation("SentMessages", fields: [senderId], references: [id])
  receiver    User          @relation("ReceivedMessages", fields: [receiverId], references: [id])
  
  // Métadonnées
  priority    Priority      @default(NORMAL)
  expiresAt   DateTime?     // Pour invitations avec timeout
  
  // Timestamps
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  @@map("messages")
  @@index([receiverId, isRead])
  @@index([receiverId, createdAt])
  @@index([receiverId, category])
}

enum MessageType {
  // Système
  SYSTEM_WELCOME
  SYSTEM_UPDATE
  SYSTEM_MAINTENANCE
  
  // Équipes
  TEAM_INVITATION
  
  // Futur : Compétition
  MATCH_CHALLENGE
  MATCH_RESULT
  TOURNAMENT_INVITE
  
  // Futur : Social
  PRIVATE_MESSAGE
  LOBBY_INVITE
}

enum MessageCategory {
  NOTIFICATION    // Notifications classiques
  INVITATION     // Nécessitent une action
  SYSTEM         // Messages système
  PRIVATE        // Messages privés (futur)
  LOBBY          // Invitations lobby (futur)
}

enum Priority {
  LOW
  NORMAL  
  HIGH
  URGENT
}

// ===========================
// SYSTÈME LADDER INDIVIDUEL
// ===========================

model LadderPlayer {
  id          String   @id @default(cuid())
  
  // Relations
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Statistiques par jeu et mode
  game        Game
  gameMode    String   // "1v1" pour les compétitions individuelles
  
  // Statistiques
  victories   Int      @default(0)
  defeats     Int      @default(0)
  matchesPlayed Int    @default(0)
  
  // Position dans le classement (calculée dynamiquement)
  rank        Int?
  
  // Dernière activité
  lastMatchAt DateTime?
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations matches
  challengesCreated   Challenge[]  @relation("ChallengeCreator")
  challengesAccepted  Challenge[]  @relation("ChallengeAcceptor")
  matchesAsPlayer1    Match[]      @relation("MatchPlayer1")
  matchesAsPlayer2    Match[]      @relation("MatchPlayer2")
  
  @@unique([userId, game, gameMode])
  @@map("ladder_players")
  @@index([game, gameMode, victories, defeats])
}

model Challenge {
  id            String          @id @default(cuid())
  
  // Relations
  creatorId     String
  acceptorId    String?
  creator       LadderPlayer    @relation("ChallengeCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  acceptor      LadderPlayer?   @relation("ChallengeAcceptor", fields: [acceptorId], references: [id], onDelete: SetNull)
  
  // Informations du défi
  game          Game
  gameMode      String          // "1v1"
  scheduledAt   DateTime        // Heure prévue du match
  expiresAt     DateTime        // Heure limite d'acceptation (= scheduledAt)
  
  // Statuts
  status        ChallengeStatus @default(PENDING)
  
  // Message optionnel
  message       String?
  
  // Match associé (une fois accepté)
  matchId       String?         @unique
  match         Match?          @relation(fields: [matchId], references: [id])
  
  // Timestamps
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  @@map("challenges")
  @@index([game, gameMode, status])
  @@index([scheduledAt, status])
}

enum ChallengeStatus {
  PENDING     // En attente d'acceptation
  ACCEPTED    // Accepté, match en cours
  EXPIRED     // Expiré (heure passée)
  CANCELLED   // Annulé par le créateur
  COMPLETED   // Match terminé
}

model Match {
  id            String      @id @default(cuid())
  
  // Relations
  player1Id     String
  player2Id     String
  player1       LadderPlayer @relation("MatchPlayer1", fields: [player1Id], references: [id])
  player2       LadderPlayer @relation("MatchPlayer2", fields: [player2Id], references: [id])
  
  // Challenge d'origine
  challenge     Challenge?
  
  // Informations du match
  game          Game
  gameMode      String      // "1v1"
  scheduledAt   DateTime    // Heure prévue du match
  
  // Résultat
  status        MatchStatus @default(IN_PROGRESS)
  winnerId      String?     // ID du gagnant (LadderPlayer)
  loserId       String?     // ID du perdant (LadderPlayer)
  
  // Score (optionnel)
  player1Score  Int?
  player2Score  Int?
  
  // Validation du résultat
  resultSubmittedBy String?    // ID du joueur qui a soumis le résultat
  resultSubmittedAt DateTime?  // Quand le résultat a été soumis
  isDisputed        Boolean    @default(false)
  
  // Preuves (screenshots)
  proofUrls     Json?       // URLs des screenshots de preuve
  
  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  completedAt   DateTime?   // Quand le match a été complété
  
  // Relation avec les conflits
  disputes      Dispute[]
  
  @@map("matches")
  @@index([game, gameMode, status])
  @@index([scheduledAt])
  @@index([status, createdAt])
}

enum MatchStatus {
  IN_PROGRESS   // Match en cours
  COMPLETED     // Match terminé et validé
  DISPUTED      // Résultat contesté
  CANCELLED     // Match annulé
}

model Dispute {
  id          String        @id @default(cuid())
  
  // Relations
  matchId     String
  match       Match         @relation(fields: [matchId], references: [id], onDelete: Cascade)
  disputedBy  String        // ID du joueur qui conteste (User ID)
  
  // Détails du conflit
  reason      String        // Raison du conflit
  description String?       // Description détaillée
  proofUrls   Json?         // URLs des preuves du joueur qui conteste
  
  // Statut
  status      DisputeStatus @default(PENDING)
  
  // Résolution
  resolvedBy  String?       // ID de l'admin/modérateur qui résout
  resolution  String?       // Explication de la résolution
  resolvedAt  DateTime?
  
  // Timestamps
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  @@map("disputes")
  @@index([status])
  @@index([createdAt])
}

enum DisputeStatus {
  PENDING     // En attente de résolution
  RESOLVED    // Résolu
  REJECTED    // Rejeté (pas de conflit valide)
}

